// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "cache_server.h"
#include "cache_web.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <string>
#include <curl/curl.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::aos;

class cache_serverHandler : virtual public cache_serverIf {
    private:
        ParentCache* cache;
    public:
        cache_serverHandler(ParentCache* Scache) {
            cache = Scache;
        }

        static size_t write_data(char* ptr, size_t size, size_t nmemb, std::string* userdata) {
            userdata->append(ptr,size*nmemb);
            return size*nmemb;
        }

        void ping(std::string& _return, const std::string& url) {
            cache->inc_request();
            cache->data_publish();
            /*bool tmp = cache->isURL(url);
            if (tmp) {
            //std::cout << "true" << std::endl;
            }*/

            if (cache->isURL(url)) {
                std::cout << "HIT" << std::endl;
                cache->inc_hit();
                _return = cache->retrieve(url);

            }
            else {
                std::cout << "MISS" << std::endl;
                std::string body;
                CURL *curl= curl_easy_init();
                if (curl) {
                    curl_easy_setopt(curl,CURLOPT_URL,url.c_str());
                    curl_easy_setopt(curl,CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
                    curl_easy_setopt(curl,CURLOPT_WRITEDATA,&body);
                    curl_easy_setopt(curl,CURLOPT_WRITEFUNCTION, write_data);
                    CURLcode res;
                    res = curl_easy_perform(curl);
                    curl_easy_cleanup(curl);
                }
                else {
                    fprintf(stderr, "Error in GET");
                }
                //std::cout << "Got page from web" << body.size() << std::endl;
                cache->replace(url,body);
                _return = body;
            }
        }

};

int main(int argc, char **argv) {

    ParentCache* cache;
    //cache = new RandomCache();
    //cache = new LRUCache();
    cache = new LRU_MINCache();

    int port = 9090;
    shared_ptr<cache_serverHandler> handler(new cache_serverHandler(cache));
    shared_ptr<TProcessor> processor(new cache_serverProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();

    return 0;
}

